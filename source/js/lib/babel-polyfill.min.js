/**
 * Минимальный набор полифиллов для поддержки современного JavaScript в старых браузерах
 */
(function(global) {
    // Проверяем и добавляем полифиллы только если они отсутствуют

    // Array.prototype.forEach
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function(callback, thisArg) {
            if (this == null) {
                throw new TypeError('this is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var T = thisArg;
            var k = 0;
            while (k < len) {
                if (k in O) {
                    callback.call(T, O[k], k, O);
                }
                k++;
            }
        };
    }

    // Array.prototype.map
    if (!Array.prototype.map) {
        Array.prototype.map = function(callback, thisArg) {
            if (this == null) {
                throw new TypeError('this is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var T = thisArg;
            var A = new Array(len);
            var k = 0;
            while (k < len) {
                if (k in O) {
                    A[k] = callback.call(T, O[k], k, O);
                }
                k++;
            }
            return A;
        };
    }

    // Array.prototype.filter
    if (!Array.prototype.filter) {
        Array.prototype.filter = function(callback, thisArg) {
            if (this == null) {
                throw new TypeError('this is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var T = thisArg;
            var A = [];
            var k = 0;
            while (k < len) {
                if (k in O) {
                    var kValue = O[k];
                    if (callback.call(T, kValue, k, O)) {
                        A.push(kValue);
                    }
                }
                k++;
            }
            return A;
        };
    }

    // Array.prototype.find
    if (!Array.prototype.find) {
        Array.prototype.find = function(callback, thisArg) {
            if (this == null) {
                throw new TypeError('this is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var T = thisArg;
            var k = 0;
            while (k < len) {
                if (k in O) {
                    var kValue = O[k];
                    if (callback.call(T, kValue, k, O)) {
                        return kValue;
                    }
                }
                k++;
            }
            return undefined;
        };
    }

    // String.prototype.includes
    if (!String.prototype.includes) {
        String.prototype.includes = function(search, start) {
            if (typeof start !== 'number') {
                start = 0;
            }
            if (start + search.length > this.length) {
                return false;
            } else {
                return this.indexOf(search, start) !== -1;
            }
        };
    }

    // Object.assign
    if (typeof Object.assign !== 'function') {
        Object.assign = function(target) {
            if (target == null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource != null) {
                    for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }

    // Promise
    if (typeof global.Promise !== 'function') {
        // Простой полифилл для Promise (не полная реализация)
        global.Promise = function(executor) {
            var self = this;
            self.status = 'pending';
            self.value = undefined;
            self.reason = undefined;
            self.onFulfilledCallbacks = [];
            self.onRejectedCallbacks = [];

            function resolve(value) {
                if (self.status === 'pending') {
                    self.status = 'fulfilled';
                    self.value = value;
                    self.onFulfilledCallbacks.forEach(function(callback) {
                        callback(self.value);
                    });
                }
            }

            function reject(reason) {
                if (self.status === 'pending') {
                    self.status = 'rejected';
                    self.reason = reason;
                    self.onRejectedCallbacks.forEach(function(callback) {
                        callback(self.reason);
                    });
                }
            }

            try {
                executor(resolve, reject);
            } catch (e) {
                reject(e);
            }
        };

        Promise.prototype.then = function(onFulfilled, onRejected) {
            var self = this;
            var promise2 = new Promise(function(resolve, reject) {
                if (self.status === 'fulfilled') {
                    setTimeout(function() {
                        try {
                            if (typeof onFulfilled !== 'function') {
                                resolve(self.value);
                            } else {
                                var x = onFulfilled(self.value);
                                resolve(x);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);
                }

                if (self.status === 'rejected') {
                    setTimeout(function() {
                        try {
                            if (typeof onRejected !== 'function') {
                                reject(self.reason);
                            } else {
                                var x = onRejected(self.reason);
                                resolve(x);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }, 0);
                }

                if (self.status === 'pending') {
                    self.onFulfilledCallbacks.push(function(value) {
                        setTimeout(function() {
                            try {
                                if (typeof onFulfilled !== 'function') {
                                    resolve(value);
                                } else {
                                    var x = onFulfilled(value);
                                    resolve(x);
                                }
                            } catch (e) {
                                reject(e);
                            }
                        }, 0);
                    });

                    self.onRejectedCallbacks.push(function(reason) {
                        setTimeout(function() {
                            try {
                                if (typeof onRejected !== 'function') {
                                    reject(reason);
                                } else {
                                    var x = onRejected(reason);
                                    resolve(x);
                                }
                            } catch (e) {
                                reject(e);
                            }
                        }, 0);
                    });
                }
            });

            return promise2;
        };

        Promise.prototype.catch = function(onRejected) {
            return this.then(null, onRejected);
        };

        Promise.resolve = function(value) {
            return new Promise(function(resolve) {
                resolve(value);
            });
        };

        Promise.reject = function(reason) {
            return new Promise(function(resolve, reject) {
                reject(reason);
            });
        };

        Promise.all = function(promises) {
            return new Promise(function(resolve, reject) {
                if (!Array.isArray(promises)) {
                    return reject(new TypeError('Promise.all accepts an array'));
                }

                var results = [];
                var remaining = promises.length;

                if (remaining === 0) {
                    resolve(results);
                    return;
                }

                function resolver(index) {
                    return function(value) {
                        results[index] = value;
                        remaining--;
                        if (remaining === 0) {
                            resolve(results);
                        }
                    };
                }

                for (var i = 0; i < promises.length; i++) {
                    promises[i].then(resolver(i), reject);
                }
            });
        };
    }

    console.log('Babel polyfills loaded successfully');
})(typeof window !== 'undefined' ? window : global); 