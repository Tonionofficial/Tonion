/**
 * Simplified Babel standalone for browser
 * This is a minimal implementation to transform modern JS to ES5
 */
(function(global) {
    // Simple Babel-like transformer for basic ES6 features
    global.Babel = {
        // Main transform method - converts ES6+ to ES5
        transform: function(code) {
            try {
                // Very basic transformations
                // Replace arrow functions with regular functions
                code = code.replace(/(\(.*?\)\s*=>\s*{)/g, function(match, p1) {
                    // Extract parameters
                    var params = p1.substring(1, p1.indexOf(')'));
                    return 'function(' + params + ') {';
                });
                
                // Replace arrow functions without brackets
                code = code.replace(/(\(.*?\)\s*=>\s*[^{].*?)([\r\n;]|$)/g, function(match, p1, p2) {
                    var params = p1.substring(1, p1.indexOf(')'));
                    var body = p1.substring(p1.indexOf('=>') + 2).trim();
                    return 'function(' + params + ') { return ' + body + '; }' + p2;
                });
                
                // Replace let/const with var
                code = code.replace(/\b(let|const)\b/g, 'var');
                
                // Replace template literals with string concatenation
                code = code.replace(/`(.*?)`/g, function(match, p1) {
                    // Very simple implementation - doesn't handle complex interpolation
                    return "'" + p1.replace(/\${(.*?)}/g, "' + $1 + '").replace(/'/g, "\\'") + "'";
                });
                
                // Handle class declaration (very basic)
                code = code.replace(/class\s+(\w+)(\s+extends\s+(\w+))?\s*{/g, function(match, className, ext, parentName) {
                    if (ext) {
                        return 'function ' + className + '() { ' + parentName + '.apply(this, arguments); ';
                    } else {
                        return 'function ' + className + '() { ';
                    }
                });
                
                return { code: code };
            } catch (e) {
                console.error('Babel transform error:', e);
                // Return original code if transformation fails
                return { code: code };
            }
        },
        
        // Method to register a script to be transformed
        registerPlugin: function() {
            // Simplified - just a placeholder for compatibility
            return;
        },
        
        // Transformer for browser scripts
        transformScriptTags: function() {
            if (!document) return;
            
            var scripts = document.querySelectorAll('script[type="text/babel"]');
            
            for (var i = 0; i < scripts.length; i++) {
                var script = scripts[i];
                var code = script.innerHTML;
                var transformed = this.transform(code).code;
                
                // Create a new script tag with the transformed code
                var newScript = document.createElement('script');
                newScript.text = transformed;
                script.parentNode.insertBefore(newScript, script);
                script.parentNode.removeChild(script);
            }
        }
    };
    
    // Auto-transform when DOM is ready
    if (document && document.addEventListener) {
        document.addEventListener('DOMContentLoaded', function() {
            global.Babel.transformScriptTags();
        });
    }
    
    console.log('Babel standalone loaded successfully');
})(typeof window !== 'undefined' ? window : global); 